/// <reference types="node" />
import { ChildProcess } from "child_process";
import { BatchClusterEmitter } from "./BatchClusterEmitter";
import { AllOpts, BatchClusterOptions } from "./BatchClusterOptions";
import { BatchProcessOptions } from "./BatchProcessOptions";
import { Deferred } from "./Deferred";
import { Task } from "./Task";
export { BatchClusterOptions } from "./BatchClusterOptions";
export { BatchProcessOptions } from "./BatchProcessOptions";
export { Deferred } from "./Deferred";
export * from "./Logger";
export { Parser, SimpleParser } from "./Parser";
export { kill, pidExists, pids } from "./Pids";
export { Task } from "./Task";
/**
 * These are required parameters for a given BatchCluster.
 */
export interface ChildProcessFactory {
    /**
     * Expected to be a simple call to execFile. Platform-specific code is the
     * responsibility of this thunk. Error handlers will be registered as
     * appropriate.
     */
    readonly processFactory: () => ChildProcess | Promise<ChildProcess>;
}
/**
 * BatchCluster instances manage 0 or more homogeneous child processes, and
 * provide the main interface for enqueuing `Task`s via `enqueueTask`.
 *
 * Given the large number of configuration options, the constructor
 * receives a single options hash. The most important of these are the
 * `ChildProcessFactory`, which specifies the factory that creates
 * ChildProcess instances, and `BatchProcessOptions`, which specifies how
 * child tasks can be verified and shut down.
 */
export declare class BatchCluster extends BatchClusterEmitter {
    private readonly m;
    private readonly _tasksPerProc;
    private readonly logger;
    readonly options: AllOpts;
    private readonly observer;
    private readonly _procs;
    private _lastUsedProcsIdx;
    private _lastSpawnedProcTime;
    private readonly tasks;
    private onIdleInterval?;
    private readonly startErrorRate;
    private _spawnedProcs;
    private endPromise?;
    private _internalErrorCount;
    private readonly childEndCounts;
    constructor(opts: Partial<BatchClusterOptions> & BatchProcessOptions & ChildProcessFactory);
    private readonly beforeExitListener;
    private readonly exitListener;
    get ended(): boolean;
    /**
     * Shut down this instance, and all child processes.
     * @param gracefully should an attempt be made to finish in-flight tasks, or
     * should we force-kill child PIDs.
     */
    end(gracefully?: boolean): Deferred<void>;
    /**
     * Submits `task` for processing by a `BatchProcess` instance
     *
     * @return a Promise that is resolved or rejected once the task has been
     * attempted on an idle BatchProcess
     */
    enqueueTask<T>(task: Task<T>): Promise<T>;
    /**
     * @return true if all previously-enqueued tasks have settled
     */
    get isIdle(): boolean;
    /**
     * @return the number of pending tasks
     */
    get pendingTasks(): number;
    /**
     * @returns {number} the mean number of tasks completed by child processes
     */
    get meanTasksPerProc(): number;
    /**
     * @return the total number of child processes created by this instance
     */
    get spawnedProcs(): number;
    /**
     * @return the current number of child processes currently servicing tasks
     */
    get busyProcs(): number;
    /**
     * For integration tests:
     */
    get internalErrorCount(): number;
    private emitInternalError;
    private emitStartError;
    /**
     * Exposed only for unit tests
     *
     * @return the spawned PIDs that are still in the process table.
     */
    pids(): Promise<number[]>;
    /**
     * Get ended process counts (used for tests)
     */
    countEndedChildProcs(why: "old" | "worn" | "idle" | "broken"): number;
    private onIdle;
    private vacuumProcs;
    private execNextTask;
    private readonly maybeLaunchNewChild;
}
