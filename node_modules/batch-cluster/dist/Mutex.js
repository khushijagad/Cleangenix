"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mutex = void 0;
var Array_1 = require("./Array");
var Deferred_1 = require("./Deferred");
/**
 * Aggregate promises efficiently
 */
var Mutex = /** @class */ (function () {
    function Mutex() {
        this._pushCount = 0;
        this._arr = [];
    }
    Object.defineProperty(Mutex.prototype, "arr", {
        get: function () {
            Array_1.filterInPlace(this._arr, function (ea) { return ea.pending; });
            return this._arr;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mutex.prototype, "pushCount", {
        get: function () {
            return this._pushCount;
        },
        enumerable: false,
        configurable: true
    });
    Mutex.prototype.push = function (f) {
        this._pushCount++;
        var p = f();
        // Don't cause awaitAll to die if a task rejects:
        this.arr.push(new Deferred_1.Deferred().observeQuietly(p));
        return p;
    };
    /**
     * Run f() after all prior-enqueued promises have resolved.
     */
    Mutex.prototype.serial = function (f) {
        var _this = this;
        return this.push(function () { return _this.awaitAll().then(function () { return f(); }); });
    };
    /**
     * Only run f() if all prior have finished, otherwise, no-op and wait until
     * all pending have resolved.
     */
    Mutex.prototype.runIfIdle = function (f) {
        return this.pending ? undefined : this.serial(f);
    };
    Object.defineProperty(Mutex.prototype, "pendingCount", {
        get: function () {
            // Don't need vacuuming, so we can use this._arr:
            return this._arr.reduce(function (sum, ea) { return sum + (ea.pending ? 1 : 0); }, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mutex.prototype, "pending", {
        get: function () {
            return this.pendingCount > 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mutex.prototype, "settled", {
        get: function () {
            // this.arr is a getter that does vacuuming
            return this.arr.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @return a promise that will be resolved when all previously-pushed Promises
     * are resolved. Any promise rejection will throw the whole chain.
     */
    Mutex.prototype.awaitAll = function () {
        return this.arr.length === 0
            ? Promise.resolve(undefined)
            : Promise.all(this.arr.map(function (ea) { return ea.promise; })).then(function () { return undefined; });
    };
    return Mutex;
}());
exports.Mutex = Mutex;
//# sourceMappingURL=Mutex.js.map