"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractTzOffsetFromUTCOffset = exports.inferLikelyOffsetMinutes = exports.extractTzOffsetFromTags = exports.extractOffset = exports.offsetMinutesToZoneName = exports.reasonableTzOffsetMinutes = exports.MaxTzOffsetHours = void 0;
var luxon_1 = require("luxon");
var Array_1 = require("./Array");
var DateTime_1 = require("./DateTime");
var ExifDateTime_1 = require("./ExifDateTime");
var Maybe_1 = require("./Maybe");
var Number_1 = require("./Number");
var String_1 = require("./String");
// Pacific/Kiritimati is +14:00 TIL
// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
exports.MaxTzOffsetHours = 14;
function reasonableTzOffsetMinutes(tzOffsetMinutes) {
    return (Number_1.isNumber(tzOffsetMinutes) &&
        Math.abs(tzOffsetMinutes) < exports.MaxTzOffsetHours * 60);
}
exports.reasonableTzOffsetMinutes = reasonableTzOffsetMinutes;
/**
 * Returns a "zone name" (used by `luxon`) that encodes the given offset.
 */
function offsetMinutesToZoneName(offsetMinutes) {
    if (offsetMinutes == null || !Number_1.isNumber(offsetMinutes))
        return undefined;
    if (offsetMinutes === 0)
        return "UTC";
    var sign = offsetMinutes < 0 ? "-" : "+";
    var absMinutes = Math.abs(offsetMinutes);
    if (absMinutes > exports.MaxTzOffsetHours * 60)
        return undefined;
    var hours = Math.floor(absMinutes / 60);
    var minutes = Math.abs(absMinutes % 60);
    return ("UTC" + sign +
        (minutes === 0 ? "" + String_1.pad2(hours) : String_1.pad2(hours) + ":" + String_1.pad2(minutes)));
}
exports.offsetMinutesToZoneName = offsetMinutesToZoneName;
function dtToMs(s, defaultZone) {
    return Maybe_1.map(ExifDateTime_1.ExifDateTime.fromExifStrict(s, defaultZone), function (dt) {
        return dt.toDate().getTime();
    });
}
function utcToMs(s) {
    return dtToMs(s, "UTC");
}
function tzHourToOffset(n) {
    return Number_1.isNumber(n) && reasonableTzOffsetMinutes(n * 60)
        ? offsetMinutesToZoneName(n * 60)
        : undefined;
}
var tzRe = /(?:UTC)?([+-]?)(\d\d?)(?::(\d\d))?/;
/**
 * Parse a timezone offset and return the offset minutes
 */
function extractOffset(tz) {
    if (tz == null || String_1.blank(tz)) {
        return undefined;
    }
    if (String_1.isString(tz) && luxon_1.Info.isValidIANAZone(tz)) {
        return { tz: tz, src: "validIANAZone" };
    }
    return Maybe_1.map(tzRe.exec(tz), function (m) {
        return Maybe_1.map(offsetMinutesToZoneName((m[1] === "-" ? -1 : 1) *
            (parseInt(m[2]) * 60 + parseInt(Maybe_1.orElse(m[3], "0")))), function (ea) { return ({ tz: ea, src: "offsetMinutesToZoneName" }); });
    });
}
exports.extractOffset = extractOffset;
function extractTzOffsetFromTags(t) {
    return Maybe_1.firstDefinedThunk([
        function () {
            return Maybe_1.first([
                "TimeZone",
                "OffsetTime",
                "OffsetTimeOriginal",
                "OffsetTimeDigitized",
                "TimeZoneOffset",
            ], function (tagName) {
                return Maybe_1.map(extractOffset(t[tagName]), function (ea) { return ({
                    tz: ea.tz,
                    src: ea.src + " from " + tagName,
                }); });
            });
        },
        function () {
            return Maybe_1.map(t.TimeZoneOffset, function (value) {
                return Maybe_1.map(tzHourToOffset(Array.isArray(value) ? value[0] : value), function (tz) { return ({
                    tz: tz,
                    src: "TimeZoneOffset",
                }); });
            });
        },
    ]);
}
exports.extractTzOffsetFromTags = extractTzOffsetFromTags;
function firstUtcMs(tags, tagNames) {
    return Maybe_1.first(tagNames, function (tagName) {
        return Maybe_1.map(utcToMs(tags[tagName]), function (utcMs) { return ({ tagName: tagName, utcMs: utcMs }); });
    });
}
// timezone offsets may be on a 15 minute boundary, but if GPS acquisition is
// old, this can be spurious. We get less mistakes with a larger multiple, so
// we're using 30 minutes instead of 15. See
// https://www.timeanddate.com/time/time-zones-interesting.html
var TzBoundaryMinutes = 30;
function inferLikelyOffsetMinutes(deltaMs) {
    return TzBoundaryMinutes * Math.floor(deltaMs / DateTime_1.MinuteMs / TzBoundaryMinutes);
}
exports.inferLikelyOffsetMinutes = inferLikelyOffsetMinutes;
function extractTzOffsetFromUTCOffset(t) {
    var gpsStamps = Array_1.compact([t.GPSDateStamp, t.GPSTimeStamp]);
    var GPSDateTimeStamp = gpsStamps.length === 2 ? gpsStamps.join(" ") : undefined;
    var utc = firstUtcMs(__assign(__assign({}, t), { GPSDateTimeStamp: GPSDateTimeStamp }), [
        "GPSDateTime",
        "DateTimeUTC",
        "GPSDateTimeStamp",
    ]);
    var dt = firstUtcMs(t, [
        "SubSecDateTimeOriginal",
        "DateTimeOriginal",
        "SubSecCreateDate",
        "CreateDate",
        "SubSecMediaCreateDate",
        "MediaCreateDate",
        "DateTimeCreated",
    ]);
    if (utc == null || dt == null)
        return;
    // By flooring
    var offsetMinutes = inferLikelyOffsetMinutes(dt.utcMs - utc.utcMs);
    return Maybe_1.map(offsetMinutesToZoneName(offsetMinutes), function (tz) { return ({
        tz: tz,
        src: "offset between " + dt.tagName + " and " + utc.tagName,
    }); });
}
exports.extractTzOffsetFromUTCOffset = extractTzOffsetFromUTCOffset;
//# sourceMappingURL=Timezones.js.map