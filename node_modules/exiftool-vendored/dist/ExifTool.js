"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exiftool = exports.ExifTool = exports.DefaultExifToolOptions = exports.DefaultMaxProcs = exports.DefaultExiftoolArgs = exports.DefaultExifToolPath = exports.offsetMinutesToZoneName = exports.ExifToolTask = exports.ExifTime = exports.ExifDateTime = exports.ExifDate = void 0;
var bc = __importStar(require("batch-cluster"));
var _cp = __importStar(require("child_process"));
var _fs = __importStar(require("fs"));
var _os = __importStar(require("os"));
var _path = __importStar(require("path"));
var _p = __importStar(require("process"));
var AsyncRetry_1 = require("./AsyncRetry");
var BinaryExtractionTask_1 = require("./BinaryExtractionTask");
var Lazy_1 = require("./Lazy");
var Maybe_1 = require("./Maybe");
var ReadRawTask_1 = require("./ReadRawTask");
var ReadTask_1 = require("./ReadTask");
var RewriteAllTagsTask_1 = require("./RewriteAllTagsTask");
var String_1 = require("./String");
var VersionTask_1 = require("./VersionTask");
var WriteTask_1 = require("./WriteTask");
var ExifDate_1 = require("./ExifDate");
Object.defineProperty(exports, "ExifDate", { enumerable: true, get: function () { return ExifDate_1.ExifDate; } });
var ExifDateTime_1 = require("./ExifDateTime");
Object.defineProperty(exports, "ExifDateTime", { enumerable: true, get: function () { return ExifDateTime_1.ExifDateTime; } });
var ExifTime_1 = require("./ExifTime");
Object.defineProperty(exports, "ExifTime", { enumerable: true, get: function () { return ExifTime_1.ExifTime; } });
var ExifToolTask_1 = require("./ExifToolTask");
Object.defineProperty(exports, "ExifToolTask", { enumerable: true, get: function () { return ExifToolTask_1.ExifToolTask; } });
var Timezones_1 = require("./Timezones");
Object.defineProperty(exports, "offsetMinutesToZoneName", { enumerable: true, get: function () { return Timezones_1.offsetMinutesToZoneName; } });
var isWin32 = Lazy_1.lazy(function () { return _os.platform() === "win32"; });
function findExiftool() {
    var path = require("exiftool-vendored." + (isWin32() ? "exe" : "pl"));
    // This s/app.asar/app.asar.unpacked/ path switch adds support for Electron
    // apps that are ASAR-packed.
    // Note that we can't check for electron because child processes that are
    // spawned by the main process will most likely need the ELECTRON_RUN_AS_NODE
    // environment variable set, which will unset the process.versions.electron
    // field.
    var fixedPath = path
        .split(_path.sep)
        .map(function (ea) { return (ea === "app.asar" ? "app.asar.unpacked" : ea); })
        .join(_path.sep);
    // Note also, that we must check for the fixedPath first, because Electron's
    // ASAR shenanigans will make existsSync return true even for asar-packed
    // resources.
    if (_fs.existsSync(fixedPath)) {
        return fixedPath;
    }
    if (_fs.existsSync(path)) {
        return path;
    }
    throw new Error("Vendored ExifTool does not exist at " + path);
}
exports.DefaultExifToolPath = findExiftool();
exports.DefaultExiftoolArgs = ["-stay_open", "True", "-@", "-"];
var _ignoreShebang = Lazy_1.lazy(function () { return !isWin32() && !_fs.existsSync("/usr/bin/perl"); });
exports.DefaultMaxProcs = Math.max(1, Math.floor(_os.cpus().length / 4));
/**
 * Default values for `ExifToolOptions`, except for `processFactory` (which is
 * created by the ExifTool constructor)
 */
exports.DefaultExifToolOptions = Object.freeze(__assign(__assign({}, new bc.BatchClusterOptions()), { maxProcs: exports.DefaultMaxProcs, maxTasksPerProcess: 500, spawnTimeoutMillis: 30000, taskTimeoutMillis: 20000, onIdleIntervalMillis: 2000, streamFlushMillis: 7, taskRetries: 1, exiftoolPath: exports.DefaultExifToolPath, exiftoolArgs: exports.DefaultExiftoolArgs, exiftoolEnv: {}, pass: "{ready}", fail: "{ready}", exitCommand: "-stay_open\nFalse\n", versionCommand: new VersionTask_1.VersionTask().command, numericTags: ["*Duration*", "GPS*", "Orientation"] }));
/**
 * Manages delegating calls to a vendored running instance of ExifTool.
 *
 * Instances should be shared: consider using the exported singleton
 * instance of this class, `exiftool`.
 */
var ExifTool = /** @class */ (function () {
    function ExifTool(options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        /**
         * Register life cycle event listeners. Delegates to BatchProcess.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.on = function (event, listener) {
            return _this.batchCluster.on(event, listener);
        };
        if (options != null && typeof options !== "object") {
            throw new Error("Please update caller to the new ExifTool constructor API");
        }
        var o = __assign(__assign({}, exports.DefaultExifToolOptions), options);
        var ignoreShebang = Maybe_1.orElse(o.ignoreShebang, function () { return _ignoreShebang(); });
        var env = __assign(__assign({}, o.exiftoolEnv), { LANG: "C" });
        if (String_1.notBlank(_p.env.EXIFTOOL_HOME) && String_1.blank(env.EXIFTOOL_HOME)) {
            env.EXIFTOOL_HOME = _p.env.EXIFTOOL_HOME;
        }
        var spawnOpts = {
            stdio: "pipe",
            shell: ignoreShebang,
            detached: false,
            env: env,
        };
        var processFactory = function () {
            return ignoreShebang
                ? _cp.spawn("perl", __spread([o.exiftoolPath], o.exiftoolArgs), spawnOpts)
                : _cp.spawn(o.exiftoolPath, o.exiftoolArgs, spawnOpts);
        };
        this.options = __assign(__assign(__assign({}, o), { ignoreShebang: ignoreShebang,
            processFactory: processFactory, exitCommand: o.exitCommand, versionCommand: o.versionCommand }), options);
        this.batchCluster = new bc.BatchCluster(this.options);
    }
    /**
     * @return a promise holding the version number of the vendored ExifTool
     */
    ExifTool.prototype.version = function () {
        return this.enqueueTask(function () { return new VersionTask_1.VersionTask(); });
    };
    /**
     * Read the tags in `file`.
     *
     * @param {string} file the file to extract metadata tags from
     * @param {string[]} [args] any additional ExifTool arguments, like "-fast" or
     * "-fast2". **Most other arguments will require you to use `readRaw`.**
     * Note that the default is "-fast", so if you want ExifTool to read the
     * entire file for metadata, you should pass an empty array as the second
     * parameter. See https://exiftool.org/#performance for
     * more information about `-fast` and `-fast2`.
     * @returns {Promise<Tags>} A resolved Tags promise. If there are errors
     * during reading, the `.errors` field will be present.
     * @memberof ExifTool
     */
    ExifTool.prototype.read = function (file, args) {
        var _this = this;
        if (args === void 0) { args = ["-fast"]; }
        return this.enqueueTask(function () {
            return ReadTask_1.ReadTask.for(file, _this.options.numericTags, args);
        });
    };
    /**
     * Read the tags from `file`, without any post-processing of ExifTool values.
     *
     * **You probably want `read`, not this method. READ THE REST OF THIS COMMENT
     * CAREFULLY.**
     *
     * If you want to extract specific tag values from a file, you may want to use
     * this, but all data validation and inference heuristics provided by `read`
     * will be skipped.
     *
     * Note that performance will be very similar to `read`, and will actually be
     * worse if you don't include `-fast` or `-fast2` (as the most expensive bit
     * is the perl interpreter and scanning the file on disk).
     *
     * @param args **all ExifTool arguments**, except for the file path. If
     * `-charset` or `filename=utf8` are missing, and you have non-ascii tag
     * values, you're going to have a bad day. The resolved pathname will be
     * appended to the args array for you, and if `-json` is missing from `args`,
     * that will be prepended, as it's a prerequisite to parsing the result.
     *
     * @return Note that the return value will be similar to `Tags`, but with no
     * date, time, or other rich type parsing that you get from `.read()`, the
     * return value is wholly untyped.
     *
     * @see https://github.com/photostructure/exiftool-vendored.js/issues/44
     */
    ExifTool.prototype.readRaw = function (file, args) {
        return this.enqueueTask(function () { return ReadRawTask_1.ReadRawTask.for(file, args); });
    };
    /**
     * Write the given `tags` to `file`.
     *
     * @param {string} file an existing file to write `tags` to.
     * @param {Tags} tags the tags to write to `file`.
     * @param {string[]} [args] any additional ExifTool arguments, like "-n".
     * Most consumers won't probably need this.
     * @returns {Promise<void>} Either the promise will be resolved if the
     * tags are written to successfully, or the promise will be rejected if
     * there are errors or warnings.
     * @memberof ExifTool
     */
    ExifTool.prototype.write = function (file, tags, args) {
        return this.enqueueTask(function () { return WriteTask_1.WriteTask.for(file, tags, args); });
    };
    /**
     * This will strip `file` of all metadata tags. The original file (with the
     * name `${FILENAME}_original`) will be retained. Note that some tags, like
     * stat information and image dimensions, are intrinsic to the file and will
     * continue to exist if you re-`read` the file.
     */
    ExifTool.prototype.deleteAllTags = function (file) {
        return this.write(file, {}, ["-all="]);
    };
    /**
     * Extract the low-resolution thumbnail in `path/to/image.jpg`
     * and write it to `path/to/thumbnail.jpg`.
     *
     * Note that these images can be less than .1 megapixels in size.
     *
     * @return a `Promise<void>`. An `Error` is raised if
     * the file could not be read or the output not written.
     */
    ExifTool.prototype.extractThumbnail = function (imageFile, thumbnailFile) {
        return this.extractBinaryTag("ThumbnailImage", imageFile, thumbnailFile);
    };
    /**
     * Extract the "preview" image in `path/to/image.jpg`
     * and write it to `path/to/preview.jpg`.
     *
     * The size of these images varies widely, and is present in dSLR images.
     * Canon, Fuji, Olympus, and Sony use this tag.
     *
     * @return a `Promise<void>`. An `Error` is raised if
     * the file could not be read or the output not written.
     */
    ExifTool.prototype.extractPreview = function (imageFile, previewFile) {
        return this.extractBinaryTag("PreviewImage", imageFile, previewFile);
    };
    /**
     * Extract the "JpgFromRaw" image in `path/to/image.jpg`
     * and write it to `path/to/fromRaw.jpg`.
     *
     * This size of these images varies widely, and is not present in all RAW images.
     * Nikon and Panasonic use this tag.
     *
     * @return a `Promise<void>`. An `Error` is raised if
     * the file could not be read or the output not written.
     */
    ExifTool.prototype.extractJpgFromRaw = function (imageFile, outputFile) {
        return this.extractBinaryTag("JpgFromRaw", imageFile, outputFile);
    };
    /**
     * Extract a given binary value from "tagname" tag associated to `path/to/image.jpg`
     * and write it to `dest` (which cannot exist and whose directory must already exist).
     *
     * @return a `Promise<void>`. An `Error` is raised if
     * the binary output not be written to `dest`.
     */
    ExifTool.prototype.extractBinaryTag = function (tagname, src, dest) {
        return __awaiter(this, void 0, void 0, function () {
            var maybeError;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.enqueueTask(function () {
                            return BinaryExtractionTask_1.BinaryExtractionTask.for(tagname, src, dest);
                        })];
                    case 1:
                        maybeError = _a.sent();
                        if (maybeError != null) {
                            throw new Error(maybeError);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Attempt to fix metadata problems in JPEG images by deleting all metadata
     * and rebuilding from scratch. After repairing an image you should be able to
     * write to it without errors, but some metadata from the original image may
     * be lost in the process.
     *
     * This should only be applied as a last resort to images whose metadata is
     * not readable via {@link .read()}.
     *
     * @see https://exiftool.org/faq.html#Q20
     *
     * @param {string} inputFile the path to the problematic image
     * @param {string} outputFile the path to write the repaired image
     * @param {boolean} allowMakerNoteRepair if there are problems with MakerNote
     * tags, allow ExifTool to apply heuristics to recover corrupt tags. See
     * exiftool's `-F` flag.
     * @return {Promise<void>} resolved when outputFile has been written.
     */
    ExifTool.prototype.rewriteAllTags = function (inputFile, outputFile, allowMakerNoteRepair) {
        if (allowMakerNoteRepair === void 0) { allowMakerNoteRepair = false; }
        return this.enqueueTask(function () {
            return RewriteAllTagsTask_1.RewriteAllTagsTask.for(inputFile, outputFile, allowMakerNoteRepair);
        });
    };
    /**
     * Shut down running ExifTool child processes. No subsequent requests will be
     * accepted.
     *
     * This may need to be called in `after` or `finally` clauses in tests or
     * scripts for them to exit cleanly.
     */
    ExifTool.prototype.end = function (gracefully) {
        if (gracefully === void 0) { gracefully = true; }
        return this.batchCluster.end(gracefully).promise;
    };
    Object.defineProperty(ExifTool.prototype, "ended", {
        /**
         * @return true if `.end()` has been invoked
         */
        get: function () {
            return this.batchCluster.ended;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Most users will not need to use `enqueueTask` directly. This method
     * supports submitting custom `BatchCluster` tasks.
     *
     * @see BinaryExtractionTask for an example task implementation
     */
    ExifTool.prototype.enqueueTask = function (task) {
        var _this = this;
        return AsyncRetry_1.retryOnReject(function () { return _this.batchCluster.enqueueTask(task()); }, this.options.taskRetries);
    };
    Object.defineProperty(ExifTool.prototype, "pids", {
        /**
         * @return the currently running ExifTool processes. Note that on Windows,
         * these are only the process IDs of the directly-spawned ExifTool wrapper,
         * and not the actual perl vm. This should only really be relevant for
         * integration tests that verify processes are cleaned up properly.
         */
        get: function () {
            return this.batchCluster.pids();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExifTool.prototype, "pendingTasks", {
        /**
         * @return the number of pending (not currently worked on) tasks
         */
        get: function () {
            return this.batchCluster.pendingTasks;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExifTool.prototype, "spawnedProcs", {
        /**
         * @return the total number of child processes created by this instance
         */
        get: function () {
            return this.batchCluster.spawnedProcs;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ExifTool.prototype, "busyProcs", {
        /**
         * @return the current number of child processes currently servicing tasks
         */
        get: function () {
            return this.batchCluster.busyProcs;
        },
        enumerable: false,
        configurable: true
    });
    return ExifTool;
}());
exports.ExifTool = ExifTool;
/**
 * Use this singleton rather than instantiating new ExifTool instances in order
 * to leverage a single running ExifTool process. As of v3.0, its `maxProcs` is
 * set to the number of CPUs on the current system; no more than `maxProcs`
 * instances of `exiftool` will be spawned. You may want to experiment with
 * smaller or larger values for `maxProcs`, depending on CPU and disk speed of
 * your system and performance tradeoffs.
 *
 * Note that each child process consumes between 10 and 50 MB of RAM. If you
 * have limited system resources you may want to use a smaller `maxProcs` value.
 */
exports.exiftool = new ExifTool();
//# sourceMappingURL=ExifTool.js.map